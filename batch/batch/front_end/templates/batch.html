{% extends "layout.html" %}
{% block title %}Batch {{ batch['id'] }}{% endblock %}
{% block head %}
  <script src="{{ base_path }}/common_static/focus_on_keyup.js"></script>
  <link rel="stylesheet" type="text/css" href="{{ base_path }}/common_static/batch.css"/>
{% endblock %}
{% block content %}

<h1>Batch <span class="text-color">#{{ batch['id'] }}</span></h1>

<h2>Properties</h2>
<ul>
  <li>User: {{ batch['user'] }}</li>
  <li>Billing Project: {{ batch['billing_project'] }}</li>
  <li>Time Created: {% if 'time_created' in batch and batch['time_created'] is not none %}{{ batch['time_created'] }}{% endif %}</li>
  <li>Time Completed: {% if 'time_completed' in batch and batch['time_completed'] is not none %}{{ batch['time_completed'] }}{% endif %}</li>
  <li>Total Jobs: {{ batch['n_jobs'] }}</li>
  <ul>
    <li>Pending Jobs: {{ batch['n_jobs'] - batch['n_completed'] }}</li>
    <li>Succeeded Jobs: {{ batch['n_succeeded'] }}</li>
    <li>Failed Jobs: {{ batch['n_failed'] }}</li>
    <li>Cancelled Jobs: {{ batch['n_cancelled'] }}</li>
  </ul>
  <li>Duration: {% if 'duration' in batch and batch['duration'] is not none %}{{ batch['duration'] }}{% endif %}</li>
  <li>Cost: {% if 'cost' in batch and batch['cost'] is not none %}{{ batch['cost'] }}{% endif %}</li>
</ul>

{% if not batch['complete'] and batch['state'] != 'Cancelled' %}
<form action="{{ base_path }}/batches/{{ batch['id'] }}/cancel" method="post">
  <input type="hidden" name="_csrf" value="{{ csrf_token }}"/>
  {% if q is not none %}
  <input type="hidden" name="q" value="{{ q }}"/>
  {% endif %}
  <button>Cancel</button>
</form>
{% endif %}

<h2>Attributes</h2>
{% if 'attributes' in batch %}
{% for name, value in batch['attributes'].items() %}
<p>{{ name }}: {{ value }}</p>
{% endfor %}
{% endif %}

<div class="width-most flex justify-center">
  <div class="card">
    <h2 class="card-header" id="jobs">Jobs</h2>
    <div class="card-body child-done">
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>State</th>
            <th>Exit Code</th>
            <th>Duration</th>
            <th>Cost</th>
          </tr>
        </thead>
        <tbody id="batch-table-body"></tbody>
      </table>
    </div>
  </div>
  <div id="loading-indicator">Loading jobs...</div>
</div>

<!--
<div class="flex-col">
  <div class='flex-col' style="overflow: auto;">
    <table class="data-table" id="batch" style="width: 100%">
      <thead>
      </thead>
      <tbody id="batch-table-body"></tbody>
    </table>
  </div>
</div>
-->

<script type="text/javascript">
  // constants
  const PAGE_SIZE = 50
  const SCROLL_END = 5
  
  // DOM element references
  const page = document.getElementsByTagName("html")[0]
  const batchTableBody = document.getElementById("batch-table-body")
  const loadingIndicator = document.getElementById("loading-indicator")

  // local loading state
  let loading = true
  const renderLoadingState = () => {
    if (loading) {
      loadingIndicator.style.display = "block"
    } else {
      loadingIndicator.style.display = "none"
    }
  }
  const setLoading = (val) => {
    loading = val
    renderLoadingState()
  }

  // pagination state
  let jobIdx = 0
  const setJobIdx = (val) => {
    jobIdx = val
  }

  // jobs rendering
  const renderJobLink = (id) => {
    const linkEle = document.createElement("a")
    linkEle.className = "fill-td"
    linkEle.href = `{{ base_path }}/batches/{{ batch["id"] }}/jobs/${id}`
    linkEle.innerHTML = id
    return linkEle
  }
  const renderJobId = (id) => {
    const idEle = document.createElement("td")
    idEle.className = "numeric-cell" 
    idEle.appendChild(renderJobLink(id))
    return idEle
  }
  const renderJobField = (fieldVal) => {
    const ele = document.createElement("td")
    ele.innerHTML = fieldVal
    return ele
  }
  const renderJobRow = ({ job_id, name, state, exit_code, duration, cost }) => {
    const row = document.createElement("tr")
    const cells = [renderJobId(job_id), ...[name, state, exit_code, duration, cost].map(renderJobField)]
    cells.forEach((cell) => row.appendChild(cell))
    batchTableBody.appendChild(row)
  }
  const renderJobs = (jobs, nextJobIdx) =>
    jobs.slice(jobIdx, nextJobIdx).forEach(renderJobRow)
  const updateJobs = (jobs) => {
    setLoading(true)
    // TODO only set up infinite scroll if pageData.length > PAGE_SIZE
    const nextJobIdx = jobIdx + PAGE_SIZE 
    renderJobs(jobs, nextJobIdx)
    setLoading(false)
    setJobIdx(nextJobIdx)
  }
  const scrollUpdateJobs = () => {
    if (!loading && page.scrollHeight - page.clientHeight - page.scrollTop <= SCROLL_END) {
      updateJobs()
    }
  }

  // websocket state and handlers
  const socket = new WebSocket(`wss://${window.location.host}{{ base_path }}/api/v1alpha/batches/{{ batch['id'] }}/jobs/ws`)
  const [LOAD_INITIAL, LOAD_REST, REFRESH] = ["load_initial", "load_rest", "refresh"]
  let socketState = LOAD_INITIAL
  const nextSocketState = () =>
    socketState = socketState === LOAD_INITIAL ? LOAD_REST : REFRESH
  let excludeJobs = null
  const setExcludeJobs = (val) => {
    excludeJobs = val
  }
  let jobs = []
  const appendJobs = (val) => {
    updateJobs(val)
    jobs = [...jobs, ...val]
  }
  const socketHandlers = {
    [LOAD_INITIAL]: (data) => {
      const parsed = JSON.parse(data)
      // FIXME no slice
      setExcludeJobs(parsed.map(({ job_id }) => job_id).slice(1))
      appendJobs(parsed)
      nextSocketState()
      socket.send(`${socketState}:${excludeJobs.join(",")}`)
    },
    [LOAD_REST]: (data) => {
      // TODO only append the first pagesize jobs to the view
      console.log(JSON.parse(data))
      appendJobs(JSON.parse(data))
      nextSocketState()
    },
    [REFRESH]: (data) => {
      console.log("refresh")
      // TODO replaceJobs
    }
  }
  const socketOpen = (event) => socket.send(socketState)
  const socketMessage = (event) => {
    const handler = socketHandlers[socketState]
    if (handler !== undefined) {
      handler(event.data)
    }
  }

  // set up event listeners
  document.addEventListener("scroll", scrollUpdateJobs)
  socket.addEventListener("open", socketOpen)
  socket.addEventListener("message", socketMessage)

  // TODO job data as map from id to fields, on push from websocket update in table
  // TODO when do we re-query the db?
  // TODO can we "yield" from sql, so our paginated data is accurate to the timepoint of the original request?
  /*
   * start websocket connection
   * client sends <page size>
   * server loads all the jobs from the batch into memory
   * server sends first <page size> jobs
   * server initializes <page idx> at <page size>
   * server starts background loop
     * every <interval>
       * load all the jobs from the batch into memory
       * send <refresh> and jobs until <page idx> over the socket
   * client sends <next page> whenever the user loads more jobs
   * server sends the next <page size> jobs
   * server increments <page idx> by <page size>
   */
  // TODO make the search/filtering client-side, with a separate page for advanced search
</script>

<script type="text/javascript">
  focusOnSlash("searchBar");
</script>
{% endblock %}
