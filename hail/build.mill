//| mill-version: 1.0.4
//| mill-jvm-version: 11

package build

import com.goyeau.mill.scalafix.ScalafixModule
import org.typelevel.scalacoptions.*
import mill.*
import mill.api.{BuildCtx, Result}
import mill.scalalib.*
import mill.scalalib.Assembly.*
import mill.scalalib.TestModule.TestNg
import mill.scalalib.scalafmt.ScalafmtModule
import mill.util.{Jvm, VcsVersion}
import upickle.default.ReadWriter

object Settings {
  val hailMajorMinorVersion = "0.2"
  val hailPatchVersion = "136"
  val scalaMinorVersions = Map("2.12" -> "2.12.20", "2.12.13" -> "2.12.13", "2.13" -> "2.13.13")
}

object Deps {
  object HTTPComponents {
    val core = mvn"org.apache.httpcomponents:httpcore:4.4.14"
    val client = mvn"org.apache.httpcomponents:httpclient:4.5.13"
  }

  object Asm {
    val version: String = "9.8"
    val core = mvn"org.ow2.asm:asm:$version"
    val analysis = mvn"org.ow2.asm:asm-analysis:$version"
    val util = mvn"org.ow2.asm:asm-util:$version"
  }

  object Breeze {
    // WARNING WARNING WARNING
    // Before changing the breeze version review:
    // - https://hail.zulipchat.com/#narrow/stream/123011-Hail-Query-Dev/topic/new.20spark.20ndarray.20failures/near/41645
    // - https://github.com/hail-is/hail/pull/11555
    val core = mvn"org.scalanlp::breeze:1.1"
    val natives = mvn"org.scalanlp::breeze-natives:1.1"
  }

  object Commons {
    val io = mvn"commons-io:commons-io:2.20.0"
    val lang3 = mvn"org.apache.commons:commons-lang3:3.18.0"
    val codec = mvn"commons-codec:commons-codec:1.19.0"
  }

  object Spark {
    def core: Task[Dep] = Task.Anon(mvn"org.apache.spark::spark-core:${Env.sparkVersion()}")
    def mllib: Task[Dep] = Task.Anon(mvn"org.apache.spark::spark-mllib:${Env.sparkVersion()}")
  }

  val samtools = mvn"com.github.samtools:htsjdk:3.0.5"
  val jdistlib = mvn"net.sourceforge.jdistlib:jdistlib:0.4.5"
  val freemarker = mvn"org.freemarker:freemarker:2.3.31"
  val elasticsearch = mvn"org.elasticsearch::elasticsearch-spark-30:8.4.3"
  val gcloud = mvn"com.google.cloud:google-cloud-storage:2.55.0"
  val jna = mvn"net.java.dev.jna:jna:5.13.0"
  val json4s = mvn"org.json4s::json4s-jackson:3.7.0-M11"
  val zstd = mvn"com.github.luben:zstd-jni:1.5.5-11"
  val lz4 = mvn"org.lz4:lz4-java:1.8.0"
  val netlib = mvn"com.github.fommil.netlib:all:1.1.2"
  val avro = mvn"org.apache.avro:avro:1.11.2"
  val junixsocket = mvn"com.kohlschutter.junixsocket:junixsocket-core:2.6.1"
  val log4jApi = mvn"org.apache.logging.log4j:log4j-api:2.20.0"
  val sfl4jNop = mvn"org.slf4j:slf4j-nop:1.7.36"
  val hadoopClient = mvn"org.apache.hadoop:hadoop-client:3.3.4"
  val jackson = mvn"com.fasterxml.jackson.core:jackson-core:2.15.2"
  val sourcecode = mvn"com.lihaoyi::sourcecode:0.4.2"
  val collection_compat = mvn"org.scala-lang.modules::scala-collection-compat:2.13.0"
  // provides @nowarn212 and @nowarn213
  val scalac_compat = mvn"org.typelevel::scalac-compat-annotation:0.1.4"

  object Plugins {
    val betterModadicFor = mvn"com.olegpy::better-monadic-for:0.3.1"
  }
}

enum BuildMode derives ReadWriter {
  case dev, ci, release
}

object Env extends Module {
  def javaVersion: T[String] = Task.Input {
    System.getProperty("java.version")
  }

  def sparkVersion: T[String] = Task.Input {
    Result.Success(Task.env.getOrElse("SPARK_VERSION", "3.5.0"))
  }

  val buildMode: BuildMode = BuildMode.valueOf(millbuild.BuildConfig.buildMode)
}

trait HailModule extends ScalaModule with ScalafmtModule with ScalafixModule { outer =>
  // crossValue is defined by the RootHailModule#CrossValue trait, which this will be mixed with.
  // It propagates the cross value from the root `hail` module.
  def crossValue: String
  override def scalaVersion: T[String] = Task { Settings.scalaMinorVersions(crossValue) }

  override def javacOptions: T[Seq[String]] = Seq(
    "-Xlint:all",
    "-Werror",
    if (Env.buildMode == BuildMode.release) "-O" else "-g",
  ) ++ (if (!Env.javaVersion().startsWith("1.8")) Seq("-Xlint:-processing") else Seq())

  override def scalacOptions: T[Seq[String]] = Task {
    val disabledOptions = Set(
      ScalacOptions.warnNumericWiden, ScalacOptions.privateWarnNumericWiden,
      ScalacOptions.warnUnusedParams, ScalacOptions.privateWarnUnusedParams,
      ScalacOptions.warnUnusedImplicits, ScalacOptions.privateWarnUnusedImplicits,
      ScalacOptions.warnUnusedExplicits,
      // we don't enable the unused imports warning in 2.12, as the wconf origin filter doesn't work
      ScalacOptions.privateWarnUnusedImports,
      // 2.13 added the -Wnonunit-discard flag, which is a stronger check than -Wvalue-discard
      ScalacOptions.warnValueDiscard, ScalacOptions.privateWarnValueDiscard,

      ScalacOptions.lintInferAny,
      ScalacOptions.languageExperimentalMacros,
    )
    
    val baseOptions = ScalacOptions.default +
      ScalacOptions.source213 +
      ScalacOptions.advancedOption("no-patmat-analysis")
    
    val additionalOptions = Env.buildMode match {
      case BuildMode.`dev` =>
        ScalacOptions.verboseOptions
      // enable to help debug accessing unitialized fields
      //     + ScalacOptions.checkInit
      case BuildMode.`ci` =>
        Set(ScalacOptions.fatalWarnings)
      case BuildMode.`release` =>
        Set(
          ScalacOptions.fatalWarnings,
          ScalacOptions.optimizerMethodLocal,
          ScalacOptions.optimizerOption(":-closure-invocations"),
        )
    }

    val finalOptions = ScalacOptions.tokensForVersion(
      ScalaVersion.unsafeFromString(scalaVersion()),
      baseOptions -- disabledOptions ++ additionalOptions
    )
    if (scalaVersion().startsWith("2.13")) {
      finalOptions ++
      Seq(
      // collection types
        // type Traversable in package scala is deprecated (since 2.13.0): Use Iterable instead of Traversable
        "-Wconf:cat=deprecation&msg=type Traversable in package scala is deprecated:s",
        // type TraversableOnce in package scala is deprecated (since 2.13.0): Use IterableOnce instead of TraversableOnce
        "-Wconf:cat=deprecation&msg=type TraversableOnce:s",
        // type BufferedIterator in package scala is deprecated (since 2.13.0): Use scala.collection.BufferedIterator instead of scala.BufferedIterator
        "-Wconf:cat=deprecation&msg=type BufferedIterator in package scala is deprecated:s",
        // class Stream in package immutable is deprecated (since 2.13.0): Use LazyList (which is fully lazy) instead of Stream (which has a lazy tail only)
        "-Wconf:cat=deprecation&msg=Stream:s",
        // type Growable in package generic is deprecated (since 2.13.0): Growable was moved from collection.generic to collection.mutable
        "-Wconf:cat=deprecation&msg=type Growable in package generic is deprecated:s",
        // type GenTraversableOnce in package collection is deprecated (since 2.13.0): Gen* collection types have been removed
        "-Wconf:cat=deprecation&msg=type GenTraversableOnce in package collection is deprecated:s",
        // trait MultiMap in package mutable is deprecated (since 2.13.0): Use a scala.collection.mutable.MultiDict in the scala-collection-contrib module
        "-Wconf:cat=deprecation&msg=trait MultiMap in package mutable is deprecated:s",
        // inheritance from class HashMap in package mutable is deprecated (since 2.13.0): HashMap will be made final; use .withDefault for the common use case of computing a default value
        "-Wconf:cat=deprecation&msg=inheritance from class HashMap in package mutable is deprecated:s",
        // object JavaConverters in package collection is deprecated (since 2.13.0): Use `scala.jdk.CollectionConverters` instead
        "-Wconf:cat=deprecation&msg=object JavaConverters in package collection is deprecated:s",
        // object ImplicitConversions in package convert is deprecated (since 2.13.0): Use `scala.jdk.CollectionConverters` instead
        "-Wconf:cat=deprecation&msg=object ImplicitConversions in package convert is deprecated:s",
      // generic to immutable default
      // collection methods
        // method copyArrayToImmutableIndexedSeq in class LowPriorityImplicits2 is deprecated (since 2.13.0): implicit conversions from Array to immutable.IndexedSeq are implemented by copying; use `toIndexedSeq` explicitly if you want to copy, or use the more efficient non-copying ArraySeq.unsafeWrapArray
        "-Wconf:cat=deprecation&msg=method copyArrayToImmutableIndexedSeq in class LowPriorityImplicits2 is deprecated:s",
        // Passing an explicit array value to a Scala varargs method is deprecated (since 2.13.0) and will result in a defensive copy; Use the more efficient non-copying ArraySeq.unsafeWrapArray or an explicit toIndexedSeq call
        "-Wconf:cat=deprecation&msg=Passing an explicit array value to a Scala varargs method is deprecated:s",
        // method any2stringadd in object Predef is deprecated (since 2.13.0): Implicit injection of + is deprecated. Convert to String to call +
        "-Wconf:cat=deprecation&msg=any2stringadd:s",
        // method + in class Char is deprecated (since 2.13.0): Adding a number and a String is deprecated. Use the string interpolation `s"$num$str"`
        raw"-Wconf:cat=deprecation&msg=method \+ in class Char is deprecated:s",
        // method toIterable in trait Iterable is deprecated (since 2.13.7): toIterable is internal and will be made protected; its name is similar to `toList` or `toSeq`, but it doesn't copy non-immutable collections
        "-Wconf:cat=deprecation&msg=method toIterable in trait Iterable is deprecated:s",
        // method toIterator in class IterableOnceExtensionMethods is deprecated (since 2.13.0): Use .iterator instead
        "-Wconf:cat=deprecation&msg=toIterator:s",
        // method foreach in class IterableOnceExtensionMethods is deprecated (since 2.13.0): Use .iterator.foreach(...) instead
        "-Wconf:cat=deprecation&msg=foreach:s",
        // method nonEmpty in class IterableOnceExtensionMethods is deprecated (since 2.13.0): Use .iterator.nonEmpty instead
        "-Wconf:cat=deprecation&msg=method nonEmpty in class IterableOnceExtensionMethods is deprecated:s",
        // method view in trait IndexedSeqOps is deprecated (since 2.13.0): Use .view.slice(from, until) instead of .view(from, until)
        "-Wconf:cat=deprecation&msg=method view in trait IndexedSeqOps is deprecated:s",
        // method reverseContents in class StringBuilder is deprecated (since 2.13.0): Use reverseInPlace instead
        "-Wconf:cat=deprecation&msg=method reverseContents in class StringBuilder is deprecated:s",
        // method + in trait MapOps is deprecated (since 2.13.0): Consider requiring an immutable Map or fall back to Map.concat.
        raw"-Wconf:cat=deprecation&msg=method \+ in trait MapOps is deprecated:s",
        "-Wconf:cat=deprecation&msg=method - in trait MapOps is deprecated:s",
        // method mapValues in trait MapOps is deprecated (since 2.13.0): Use .view.mapValues(f). A future version will include a strict version of this method (for now, .view.mapValues(f).toMap).
        "-Wconf:cat=deprecation&msg=method mapValues in trait MapOps is deprecated:s",
        // method filterKeys in trait MapOps is deprecated (since 2.13.0): Use .view.filterKeys(f). A future version will include a strict version of this method (for now, .view.filterKeys(p).toMap).
        "-Wconf:cat=deprecation&msg=method filterKeys in trait MapOps is deprecated:s",
        // method - in trait SetOps is deprecated (since 2.13.0): Consider requiring an immutable Set or fall back to Set.diff
        "-Wconf:cat=deprecation&msg=method - in trait SetOps is deprecated:s",
        // method reverseMap in trait SeqOps is deprecated (since 2.13.0): Use .reverseIterator.map(f).to(...) instead of .reverseMap(f)
        "-Wconf:cat=deprecation&msg=method reverseMap in trait SeqOps is deprecated:s",
        // method transform in trait SeqOps is deprecated (since 2.13.0): Use `mapInPlace` on an `IndexedSeq` instead
        "-Wconf:cat=deprecation&msg=method transform in trait SeqOps is deprecated:s",
      // other
        // Wrap `export` in backticks to use it as an identifier, it will become a keyword in Scala 3
        "-Wconf:cat=deprecation&msg=`export`:s",
        // Widening conversion from Long to Double is deprecated because it loses precision. Write `.toDouble` instead.
        "-Wconf:cat=deprecation&msg=Widening conversion from Long to Double:s",
        "-Wconf:cat=deprecation&msg=symbol literal is deprecated:s",
        "-Wconf:cat=other-implicit-type:s",
        "-Wconf:msg=legacy-binding:s",
        raw"-Wconf:cat=unused-imports&origin=scala\.collection\.compat\._:s",
        raw"-Wconf:cat=unused-imports&origin=scala\.Option\.option2Iterable:s",
        raw"-Wconf:cat=unused-imports&origin=is\.hail\.utils\.compat\._:s",
        raw"-Wconf:msg=unused value of type org\.scalatest\..*Assertion:s",
        raw"-Wconf:msg=unused value of type org\.mockito\.stubbing\.ScalaOngoingStubbing:s",
      )
    } else {
      finalOptions :+ "-Wconf:msg=legacy-binding:s"
    }
  }

  trait HailTests extends ScalaTests with TestNg with ScalafmtModule with ScalafixModule {
    override def forkArgs: T[Seq[String]] = Seq("-Xss4m", "-Xmx4096M")

    override def mvnDeps: T[Seq[Dep]] =
      super.mvnDeps() ++ outer.compileMvnDeps() ++ Seq(
        mvn"org.scalacheck::scalacheck:1.18.1",
        mvn"org.scalatest::scalatest:3.2.19",
        mvn"org.scalatest::scalatest-shouldmatchers:3.2.19",
        mvn"org.scalatestplus::scalacheck-1-18:3.2.19.0",
        mvn"org.scalatestplus::testng-7-10:3.2.19.0",
        mvn"org.mockito::mockito-scala:1.17.31",
      )
  }
}

object hail extends Cross[RootHailModule](millbuild.BuildConfig.enabledScalaVersions)

trait RootHailModule extends CrossScalaModule with HailModule { outer =>
  def buildInfo: T[PathRef] = Task {
    val revision = VcsVersion.vcsState().currentRevision
    os.write(
      Task.dest / "build-info.properties",
      s"""[Build Metadata]
         |revision=$revision
         |sparkVersion=${Env.sparkVersion()}
         |hailPipVersion=${Settings.hailMajorMinorVersion}.${Settings.hailPatchVersion}
         |hailBuildConfiguration=${Env.buildMode}
         |""".stripMargin,
    )
    PathRef(Task.dest)
  }

  override def moduleDeps: Seq[JavaModule] = Seq(memory)

  override def resources: T[Seq[PathRef]] = super.resources() ++ Seq(
    BuildCtx.withFilesystemCheckerDisabled {
      PathRef(BuildCtx.workspaceRoot / "prebuilt" / "lib")
    },
    buildInfo(),
  )

  override def generatedSources: T[Seq[PathRef]] = Task {
    Seq(`ir-gen`.generate())
  }

  override def unmanagedClasspath: T[Seq[PathRef]] =
    Seq(shadedazure.assembly())

  // omit unmanagedClasspath from the jar
  override def jar: T[PathRef] = Task {
    val jar = Task.dest / "out.jar"
    Jvm.createJar(jar, (resources() ++ Seq(compile().classes)).map(_.path).filter(os.exists), manifest())
    PathRef(jar)
  }

  override def mvnDeps: T[Seq[Dep]] = Seq(
    Deps.HTTPComponents.core,
    Deps.HTTPComponents.client,
    Deps.Asm.core,
    Deps.Asm.analysis,
    Deps.Asm.util,
    Deps.samtools.excludeOrg("*"),
    Deps.jdistlib.excludeOrg("*"),
    Deps.freemarker,
    Deps.elasticsearch.excludeOrg("org.apache.spark"),
    Deps.gcloud.excludeOrg("com.fasterxml.jackson.core"),
    Deps.jna,
    Deps.json4s.excludeOrg("com.fasterxml.jackson.core"),
    Deps.zstd,
    Deps.sourcecode,
    Deps.collection_compat,
  )

  override def runMvnDeps: T[Seq[Dep]] = Seq(
    Deps.Breeze.natives.excludeOrg("org.apache.commons.math3"),
    Deps.Commons.io,
    Deps.Commons.lang3,
    Deps.Commons.codec,
    Deps.lz4,
    Deps.netlib,
    Deps.avro.excludeOrg("com.fasterxml.jackson.core"),
    Deps.junixsocket,
    Deps.sfl4jNop,
  )

  override def compileMvnDeps: T[Seq[Dep]] = Seq(
    Deps.log4jApi,
    Deps.hadoopClient,
    Deps.Spark.core().excludeOrg("org.scalanlp"),  // Hail has an explicit dependency on Breeze 1.1
    Deps.Spark.mllib().excludeOrg("org.scalanlp"),  // Hail has an explicit dependency on Breeze 1.1
    Deps.Breeze.core,
    Deps.jackson,
    Deps.scalac_compat,
  )

  override def assemblyRules: Seq[Rule] = super.assemblyRules ++ Seq(
    Rule.Exclude("META-INF/INDEX.LIST"),
    Rule.ExcludePattern("scala/(?!collection/compat).*"),
    Rule.AppendPattern("META-INF/services/.*", "\n"),
//    Rule.Relocate("scala.collection.compat.**", "is.hail.relocated.@0"),
    Rule.Relocate("breeze.**", "is.hail.relocated.@0"),
    Rule.Relocate("com.google.cloud.**", "is.hail.relocated.@0"),
    Rule.Relocate("com.google.common.**", "is.hail.relocated.@0"),
    Rule.Relocate("org.apache.commons.io.**", "is.hail.relocated.@0"),
    Rule.Relocate("org.apache.commons.lang3.**", "is.hail.relocated.@0"),
    Rule.Relocate("org.apache.http.**", "is.hail.relocated.@0"),
    Rule.Relocate("org.elasticsearch.**", "is.hail.relocated.@0"),
    Rule.Relocate("org.json4s.**", "is.hail.relocated.@0"),
    Rule.Relocate("org.objectweb.**", "is.hail.relocated.@0"),
  )

  override def scalacPluginMvnDeps: T[Seq[Dep]] = Seq(
    Deps.Plugins.betterModadicFor
  )

  def writeRunClasspath: T[PathRef] = Task {
    os.write(
      Task.dest / "runClasspath",
      runClasspath().map(_.path).mkString(":"),
    )
    PathRef(Task.dest)
  }

  object `ir-gen` extends HailModule with DefaultTaskModule with CrossValue {
    override def defaultTask(): String = "generate"

    override def mvnDeps = Seq(
      mvn"com.lihaoyi::mainargs:0.6.2",
      mvn"com.lihaoyi::os-lib:0.10.7",
      mvn"com.lihaoyi::sourcecode:0.4.2",
    )

    def generate: T[PathRef] = Task {
      runner().run(Args("--path", Task.dest).value)
      PathRef(Task.dest)
    }
  }

  object memory extends JavaModule with CrossValue {
    override def zincIncrementalCompilation: T[Boolean] = false

    override def javacOptions: T[Seq[String]] =
      outer.javacOptions() ++ (
        if (Env.javaVersion().startsWith("1.8")) Seq(
          "-XDenableSunApiLintControl",
          "-Xlint:-sunapi",
        )
        else Seq()
      )

    override def sources: T[Seq[PathRef]] = Task.Sources {
      val debugOrRelease = if (Env.buildMode == BuildMode.ci) "debug" else "release"
      os.sub / debugOrRelease / "src"
    }
  }

  object test extends HailTests {
    override def resources: T[Seq[PathRef]] = outer.resources() ++ super.resources()

    override def assemblyRules: Seq[Rule] = outer.assemblyRules ++ Seq(
      Rule.Relocate("org.codehaus.jackson.**", "is.hail.relocated.@0")
    )

    override def mvnDeps: T[Seq[Dep]] = super.mvnDeps() ++ Seq(
      Deps.jackson
    )

    override def compileModuleDeps: Seq[JavaModule] =
      super.compileModuleDeps ++ outer.compileModuleDeps
  }

  object shadedazure extends JavaModule {
    override def mvnDeps: T[Seq[Dep]] = Seq(
      mvn"com.azure:azure-storage-blob:12.22.0",
      mvn"com.azure:azure-core-http-netty:1.13.7",
      mvn"com.azure:azure-identity:1.8.3",
    )

    override def assemblyRules: Seq[Rule] = Seq(
      Rule.ExcludePattern("META-INF/*.RSA"),
      Rule.ExcludePattern("META-INF/*.SF"),
      Rule.ExcludePattern("META-INF/*.DSA"),
      Rule.Relocate("com.azure.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("com.ctc.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("com.fasterxml.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("com.microsoft.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("com.nimbusds.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("com.sun.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("io.netty.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("is.hail.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("net.jcip.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("net.minidev.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("org.apache.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("org.codehaus.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("org.objectweb.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("org.reactivestreams.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("org.slf4j.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("reactor.adapter.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("reactor.core.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("reactor.netty.**", "is.hail.shadedazure.@0"),
      Rule.Relocate("reactor.util.**", "is.hail.shadedazure.@0"),
    )
  }

}
